<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Uta Dev - Under Construction</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- GSAP CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>

    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(#0f172a, #1e293b, #122b53, #0f172a) !important;
            overscroll-behavior: none;
        }

        body {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .text-gradient {
            background: linear-gradient(45deg, #4f46e5, #8b5cf6, #06b6d4, #3b82f6);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientFlow 4s ease infinite;
        }

        @keyframes gradientFlow {

            0%,
            100% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }
        }

        .glass {
            --blur-amount: 3;
            background: rgba(122, 98, 158, 0.05);
            backdrop-filter: blur(calc(var(--blur-amount) * 1px));
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .glass-dark {
            background: rgba(5, 5, 50, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .bg-animated {
            background: linear-gradient(-45deg, #0f172a, #1e293b, #334155, #475569);
            background-size: 400% 400%;
            animation: bgShift 12s ease infinite;
        }

        @keyframes bgShift {

            0%,
            100% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }
        }

      
        #avatar-wrapper {
            position: relative;
            z-index: 10;
            cursor: pointer;
        }

        #avatar {
            position: relative;
        }

        #avatar-name {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
        }

        .ripple {
            position: absolute;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.7);
            transform: scale(0);
            pointer-events: none;
        }
    </style>
</head>

<body class="bg-animated text-white overflow-hidden">

    <canvas id="particle-canvas" class="fixed inset-0 pointer-events-none z-0"></canvas>

    <div class="relative min-h-screen flex flex-col items-center justify-center text-center z-10 px-6">
        <div class="glass rounded-2xl p-8 md:p-12 max-w-lg">
            <i data-lucide="construction" id="construction-icon" class="w-16 h-16 mx-auto mb-6 text-indigo-400"></i>
            <h1 id="main-heading" class="text-4xl md:text-5xl font-bold mb-4">
                <span class="text-gradient">Under Construction</span>
            </h1>
            <p id="main-paragraph" class="text-lg text-gray-300 mb-4">
                My personal website is currently being revamped. Please check back soon!
            </p>
            <p id="avatar-name" class="text-xl font-bold mb-4 opacity-0 scale-0">Tamam Huda</p>
            <div class="flex justify-center items-center space-x-4">
                <div id="avatar-wrapper" class="relative flex-shrink-0 ">
                    <img id="avatar" src="../img/profile.png" alt="Tamam Huda" class="w-12 bg-slate-900/30 h-12 
                    backdrop-blur-xs
                    rounded-full border-2 border-indigo-700/30 object-cover">
                </div>

                <a id="github-link" href="https://www.github.com/tamamhuda/" target="_blank"
                    class="glass-dark px-6 py-3 rounded-full flex items-center space-x-2">
                    <i data-lucide="github" class="w-5 h-5"></i>
                    <span>GitHub</span>
                </a>
                <a id="linkedin-link" href="https://www.linkedin.com/in/tamamhuda/" target="_blank"
                    class="glass-dark px-6 py-3 rounded-full flex items-center space-x-2">
                    <i data-lucide="linkedin" class="w-5 h-5"></i>
                    <span>LinkedIn</span>
                </a>
            </div>
        </div>
    </div>

    <script>
        gsap.config({ force3D: true });
        let isLightMode = false; 

        document.addEventListener('DOMContentLoaded', () => {
            lucide.createIcons();
            initParticleNetwork();
            initAvatarAnimation();
        });
        function initAvatarAnimation() {
            const avatar = document.getElementById('avatar');
            const avatarWrapper = document.getElementById('avatar-wrapper');
            const container = document.querySelector('.glass');
            const githubLink = document.getElementById('github-link');
            const linkedinLink = document.getElementById('linkedin-link');
            const mainHeading = document.getElementById('main-heading');
            const mainParagraph = document.getElementById('main-paragraph');
            const constructionIcon = document.getElementById('construction-icon');
            const avatarName = document.getElementById('avatar-name');

            if (!avatar || !container || !avatarWrapper || !githubLink || !linkedinLink || !mainHeading || !mainParagraph || !constructionIcon || !avatarName) {
                console.error('Required elements not found for animation');
                return;
            }

            let isAvatarOpen = false;

            const getScale = () => {
                const containerWidth = container.offsetWidth;
                const avatarWidth = avatar.offsetWidth;
                if (avatarWidth === 0) return 1;
                const desiredScale = (containerWidth * 0.4) / avatarWidth;
                return Math.max(1, Math.min(desiredScale, 5));
            };

            const getAvatarX = () => {
                const containerRect = container.getBoundingClientRect();
                const wrapperRect = avatarWrapper.getBoundingClientRect();
                return (containerRect.left + containerRect.width / 2) - (wrapperRect.left + wrapperRect.width / 2);
            };

            const getAvatarY = () => {
                const containerRect = container.getBoundingClientRect();
                const wrapperRect = avatarWrapper.getBoundingClientRect();

                const destinationY = containerRect.top + (containerRect.height * 0.35);
                const initialY = wrapperRect.top + (wrapperRect.height / 2);

                return destinationY - initialY;
            };

            const getButtonX = (target) => {
                const containerRect = container.getBoundingClientRect();
                const githubRect = githubLink.getBoundingClientRect();
                const linkedinRect = linkedinLink.getBoundingClientRect();

                const space = 16;
                const groupWidth = githubRect.width + linkedinRect.width + space;
                const groupLeft = (containerRect.left + containerRect.width / 2) - (groupWidth / 2);

                let desiredX;
                if (target === githubLink) {
                    desiredX = groupLeft;
                } else {
                    desiredX = groupLeft + githubRect.width + space;
                }
                return desiredX - target.getBoundingClientRect().left;
            };

            const getButtonY = () => {
                const containerRect = container.getBoundingClientRect();
                // Match the avatar positioning - use 40% instead of 30%
                const avatarDestinationY = containerRect.top + (containerRect.height * 0.35);
                const scale = getScale();
                const scaledAvatarHeight = avatar.offsetHeight * scale;
                const nameHeight = 28; // Approximate height of name text
                const spacing = 20; // Space between name and buttons

                const buttonsDestinationY = avatarDestinationY + (scaledAvatarHeight / 2) + nameHeight + spacing;
                const currentButtonY = githubLink.getBoundingClientRect().top;

                return buttonsDestinationY - currentButtonY;
            };

            const getNameX = () => {
                const containerRect = container.getBoundingClientRect();
                const nameRect = avatarName.getBoundingClientRect();
                return (containerRect.left + containerRect.width / 2) - (nameRect.left + nameRect.width / 2);
            };

            const getNameY = () => {
                const containerRect = container.getBoundingClientRect();
                const avatarDestinationY = containerRect.top + (containerRect.height * 0.325);
                const scale = getScale();
                const scaledAvatarHeight = avatar.offsetHeight * scale;
                const nameSpacing = 16;

                const nameDestinationY = avatarDestinationY + (scaledAvatarHeight / 2) + nameSpacing;
                const currentNameY = avatarName.getBoundingClientRect().top;

                return nameDestinationY - currentNameY;
            };

            const avatarTimeline = gsap.timeline({
                paused: true,
                onComplete: () => { isAvatarOpen = true; },
                onReverseComplete: () => { isAvatarOpen = false; }
            })
                .to(container, {
                    '--blur-amount': 1.5,
                    duration: 0.4,
                    ease: 'power2.out'
                }, 0)
                .to(avatarWrapper, {
                    scale: getScale,
                    x: getAvatarX,
                    y: getAvatarY,
                    duration: 0.4,
                    ease: 'power2.out'
                }, 0)
                .to(avatar, {
                    boxShadow: '0px 5px 25px 3px rgba(99, 102, 241, 0.4)',
                    duration: 0.4,
                    ease: 'power2.out'
                }, 0)
                .to(avatarName, {
                    x: getNameX,
                    y: getNameY,
                    scale: 1,
                    opacity: 1,
                    duration: 0.5,
                    stagger: 0.1,
                    delay: 0.05,
                    ease: 'power2.out'
                }, 0)
                .to([githubLink, linkedinLink], {
                    x: (i, target) => getButtonX(target),
                    y: () => getButtonY(),
                    duration: 0.4,
                    delay: 0.1,
                    ease: 'power2.out'
                }, 0)
                .to([mainHeading, mainParagraph, constructionIcon], {
                    opacity: 0,
                    y: -20,
                    duration: 0.3,
                    ease: 'power2.in'
                }, 0);

            function closeAvatarOnClickOutside(event) {
                if (isAvatarOpen && !avatarWrapper.contains(event.target)) {
                    avatarTimeline.reverse();
                    document.removeEventListener('click', closeAvatarOnClickOutside);
                }
            }

            avatarWrapper.addEventListener('click', (event) => {
                event.stopPropagation();
                if (!isAvatarOpen) {
                    avatarTimeline.play();
                    document.addEventListener('click', closeAvatarOnClickOutside);
                }
            });

            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    if (!isAvatarOpen) {
                        avatarTimeline.invalidate();
                    }
                }, 100);
            });
        }
        function initParticleNetwork() {
            const canvas = document.getElementById('particle-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            let particles = [];
            let numParticles = window.innerWidth > 768 ? 100 : 40;
            const connectDistance = 120;
            let mouse = {
                x: undefined,
                y: undefined,
            };

            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                numParticles = window.innerWidth > 768 ? 100 : 40;
                init();
            }
            window.addEventListener('resize', resizeCanvas);

            window.addEventListener('mousemove', (event) => {
                mouse.x = event.x;
                mouse.y = event.y;
            });
            window.addEventListener('mouseout', () => {
                mouse.x = undefined;
                mouse.y = undefined;
            });

            class Particle {
                constructor(x, y, directionX, directionY, size, color) {
                    this.x = x; this.y = y; this.directionX = directionX; this.directionY = directionY; this.size = size; this.color = color;
                }
                draw() {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                }
                update() {
                    if (this.x > canvas.width || this.x < 0) { this.directionX = -this.directionX; }
                    if (this.y > canvas.height || this.y < 0) { this.directionY = -this.directionY; }
                    this.x += this.directionX;
                    this.y += this.directionY;
                    this.draw();
                }
            }

            function init() {
                particles = [];
                for (let i = 0; i < numParticles; i++) {
                    let size = Math.random() * 1.5 + 1;
                    let x = Math.random() * (innerWidth - size * 2) + size;
                    let y = Math.random() * (innerHeight - size * 2) + size;
                    let directionX = (Math.random() * .4) - .2;
                    let directionY = (Math.random() * .4) - .2;
                    let color = isLightMode ? 'rgba(15, 23, 42, 0.05)' : 'rgba(255, 255, 255, 0.05)';
                    particles.push(new Particle(x, y, directionX, directionY, size, color));
                }
            }

            function connect() {
                let opacityValue = 1;
                for (let a = 0; a < particles.length; a++) {
                    if (mouse.x !== undefined && mouse.y !== undefined) {
                        let distance = ((particles[a].x - mouse.x) * (particles[a].x - mouse.x)) + ((particles[a].y - mouse.y) * (particles[a].y - mouse.y));
                        if (distance < (connectDistance * connectDistance)) {
                            opacityValue = (1 - (distance / (connectDistance * connectDistance))) * 0.15;
                            let color = isLightMode ? 'rgba(15, 23, 42, ' + opacityValue + ')' : 'rgba(255, 255, 255, ' + opacityValue + ')';
                            ctx.strokeStyle = color;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(particles[a].x, particles[a].y);
                            ctx.lineTo(mouse.x, mouse.y);
                            ctx.stroke();
                        }
                    }
                    for (let b = a; b < particles.length; b++) {
                        let distance = ((particles[a].x - particles[b].x) * (particles[a].x - particles[b].x)) + ((particles[a].y - particles[b].y) * (particles[a].y - particles[b].y));
                        if (distance < (connectDistance * connectDistance)) {
                            opacityValue = (1 - (distance / (connectDistance * connectDistance))) * 0.15;
                            let color = isLightMode ? 'rgba(15, 23, 42, ' + opacityValue + ')' : 'rgba(255, 255, 255, ' + opacityValue + ')';
                            ctx.strokeStyle = color;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(particles[a].x, particles[a].y);
                            ctx.lineTo(particles[b].x, particles[b].y);
                            ctx.stroke();
                        }
                    }
                }
            }

            function animate() {
                requestAnimationFrame(animate);
                ctx.clearRect(0, 0, innerWidth, innerHeight);
                for (let i = 0; i < particles.length; i++) {
                    particles[i].update();
                }
                connect();
            }
            resizeCanvas();
            animate();
        }
    </script>
</body>

</html>